#!/usr/bin/env deno run --allow-net

// Test script execution via WebSocket - LLM generates code, sends it as script

async function testScriptExecution() {
  console.log("üöÄ Testing Script Execution via WebSocket\n");

  const ws = new WebSocket("ws://localhost:9002/ws");

  await new Promise((resolve, reject) => {
    ws.onopen = () => {
      console.log("‚úÖ WebSocket connected");
      resolve(void 0);
    };
    ws.onerror = () => reject(new Error("WebSocket connection failed"));
  });

  const callId = `script_${Date.now()}`;

  // This is what an LLM would generate - TypeScript code using the injected rpc client
  const llmGeneratedScript = `
// Pokemon Team Analysis Script Generated by LLM
// The 'rpc' object is automatically injected by the system

console.log("üéÆ Starting Pokemon Team Analysis...");

// Analyze a competitive team
const team = ["charizard", "blastoise", "venusaur", "pikachu", "alakazam", "machamp"];
console.log(\`Analyzing team: \${team.join(", ")}\`);

// Execute all RPC calls in parallel for maximum performance
const [analysis, battle, rec] = await Promise.all([
  rpc.pokemon.analyzeTeam({ teamNames: team }),
  rpc.pokemon.comparePokemon({ pokemon1: "mewtwo", pokemon2: "mew" }),
  rpc.pokemon.recommendPokemon({ type: "fire", minStatTotal: 500 })
]);

console.log("\\nüèÜ Team Analysis Results:");
console.log(\`Strengths: \${analysis.strengths.join(", ")}\`);
console.log(\`Weaknesses: \${analysis.weaknesses.join(", ")}\`);
console.log(\`Offensive Coverage: \${analysis.coverage.offensiveTypes.length} types\`);
console.log(\`Defensive Gaps: \${analysis.coverage.defensiveGaps.join(", ")}\`);

console.log("\\n‚öîÔ∏è Legendary Battle: Mewtwo vs Mew");
console.log(\`Battle Prediction: \${battle.analysis.recommendation}\`);

console.log("\\nüé≤ Getting Fire-type recommendation...");
console.log(\`Recommended: \${rec.pokemon.name} - \${rec.reason}\`);

// Final report
const report = {
  timestamp: new Date().toISOString(),
  teamSize: analysis.team.length,
  teamStrengths: analysis.strengths.length,
  battleWinner: battle.analysis.recommendation.includes("Mewtwo") ? "Mewtwo" : "Mew",
  recommendation: rec.pokemon.name,
  totalApiCalls: analysis.team.length + 2 + 1 // team + battle + recommendation
};

console.log("\\nüìã FINAL REPORT:");
console.log(JSON.stringify(report, null, 2));
`;

  // Send script execution message
  const message = {
    script: llmGeneratedScript,
    id: callId
  };

  console.log("üì§ Sending LLM-generated script for execution:");
  console.log(`Script length: ${llmGeneratedScript.length} characters`);
  console.log(`Message ID: ${callId}\n`);

  return new Promise((resolve, reject) => {
    const timeout = setTimeout(() => {
      reject(new Error("Script execution timeout"));
    }, 30000);

    // Track WebSocket state changes
    ws.onclose = () => {
      console.log("üîå WebSocket connection closed by server/client auto-disconnect");
    };

    const handler = (event: MessageEvent) => {
      try {
        const response = JSON.parse(event.data);
        if (response.id === callId) {
          ws.removeEventListener('message', handler);
          clearTimeout(timeout);

          console.log("üì• Script execution completed!\n");

          if (response.error) {
            console.log("‚ùå Script execution failed:");
            console.log(response.error);
          } else {
            console.log("‚úÖ Script execution successful!");
            console.log("üìÑ Output:");
            console.log(response.result);
            console.log("\nüéâ This demonstrates the full power:");
            console.log("‚Ä¢ LLM writes TypeScript code using generated client");
            console.log("‚Ä¢ Code sent as single WebSocket message");
            console.log("‚Ä¢ Executed in sandboxed Deno environment");
            console.log("‚Ä¢ Multiple RPC calls orchestrated within script");
            console.log("‚Ä¢ Complex data analysis and reporting");
          }

          console.log("\n‚è∞ Waiting for auto-disconnect... (should happen within ~200ms)");

          // Wait a bit to see if connection auto-closes, then resolve
          setTimeout(() => {
            if (ws.readyState === WebSocket.OPEN) {
              console.log("‚ö†Ô∏è WebSocket still open - connection did not auto-disconnect");
              ws.close();
            } else {
              console.log("‚úÖ WebSocket auto-disconnected successfully");
            }
            resolve(response);
          }, 500); // Wait 500ms to see auto-disconnect
        }
      } catch (e) {
        // Ignore other messages
      }
    };

    ws.addEventListener('message', handler);
    console.log("üì° WebSocket state before sending:", ws.readyState === WebSocket.OPEN ? "OPEN" : "CLOSED");
    ws.send(JSON.stringify(message));
  });
}

if (import.meta.main) {
  try {
    await testScriptExecution();
    console.log("\nüèÅ Test completed!");
  } catch (error) {
    console.error("‚ùå Test failed:", error);
  }
}